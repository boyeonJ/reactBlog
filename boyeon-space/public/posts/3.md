
## 스타일 정보를 headless 컴포넌트에 전달하는 방법: css함수와 className

`css함수를 props`로 넘기게 되면 받는 컴포넌트는 `className이라는 props`로 전달 받습니다.

따라서 기능은 같은데 스타일이 다를경우 headless component에 스타일을 props로 넘기는 방식으로 구현하여 재사용성을 높일 수 있습니다.



#### button 공통 컴포넌트(headless component)
```jsx
export type ButtonProps = {
  onClick?: React.MouseEventHandler<HTMLElement>;
};

const Button = ({ className, children, onClick }: FoundationProps & ButtonProps) => {
  return <button onClick={onClick} className={className}>{children}</button>;
};

export default Button;
```

#### style 주입
```jsx
import Icon, { IconProps } from "./Icon";
import Button, { ButtonProps } from "./foundation/Button";

const iconButton = ({
  onClick,
  name,
  size = "medium",
  color = "primary3",
}: IconProps & ButtonProps) => {

  return (
    <Button
      onClick={onClick}
      css={{
        backgroundColor: "transparent",
        borderColor: "transparent",
      }}
    >
      <Icon name={name} size={size} color={color}></Icon>
    </Button>
  );
};

export default iconButton;
```

[참고](https://emotion.sh/docs/best-practices#method-2-share-styles-via-component-reuse)

## 최적화 하는 방법

### 1. 동적 style -> style props / 정적 style -> css props

css props는 `class를 자동으로 생성`합니다. 따라서 `정적인 스타일 객체`는 **하나의 class**로 `재사용`됩니다. 

그런데 css 스타일 객체 중에 단 하나라도 `동적인 속성`이 있을 경우에는 반복되는 속성 모두를 **독립적인 class**로 생성합니다. 이는 반복되는 코드를 만들어서 메모리 낭비를 발생시킵니다.

따라서 동적 style 객체는 style props로(inline-style), 그리고 정적 style 스타일 객체는 css props(className)으로 작성해주어야 합니다.

[참고](https://emotion.sh/docs/best-practices#use-the-style-prop-for-dynamic-styles)

### 2. component 바깥에 css 함수 미리 정의하고 재 활용하기
만약 inline style처럼 컴포넌트 `내부에 직접 Css 함수`를 작성하면 해당 컴포넌트가 `재랜더링 될때마다 직렬화`를 해주어야 합니다. 이는 비용을 발생시킵니다. 따라서 `component 밖에 미리 정의`하여 `직렬화는 단 한번`만 해줄 수 있도록 하면 `성능을 향상` 시킬 수 있습니다.

```jsx
const skillStyle = {
  title: css({ paddingBottom: "10px", display: "inline-block" }),
  layout: css({
    borderTop: `2px solid ${colors.gray1}`,
  }),
  ...
};


const Skill = () => {
  return (
    <>
      <StyledTypography variant="h1" css={skillStyle.title}>
        기술 스택
      </StyledTypography>
      <FlexBox css={skillStyle.layout}>
        ...
      </FlexBox>
    </>
  );
};
```

[참고](https://emotion.sh/docs/best-practices#consider-defining-styles-outside-your-components)